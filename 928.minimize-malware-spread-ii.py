#
# @lc app=leetcode id=928 lang=python3
#
# [928] Minimize Malware Spread II
#
# https://leetcode.com/problems/minimize-malware-spread-ii/description/
#
# algorithms
# Hard (40.24%)
# Likes:    178
# Dislikes: 43
# Total Accepted:    9K
# Total Submissions: 22.3K
# Testcase Example:  '[[1,1,0],[1,1,0],[0,0,1]]\n[0,1]'
#
# (This problem is the same as Minimize Malware Spread, with the differences
# bolded.)
#
# In a network of nodes, each node i is directly connected to another node j if
# and only if graph[i][j] = 1.
#
# Some nodes initial are initially infected by malware.  Whenever two nodes are
# directly connected and at least one of those two nodes is infected by
# malware, both nodes will be infected by malware.  This spread of malware will
# continue until no more nodes can be infected in this manner.
#
# Suppose M(initial) is the final number of nodes infected with malware in the
# entire network, after the spread of malware stops.
#
# We will remove one node from the initial list, completely removing it and any
# connections from this node to any other node.  Return the node that if
# removed, would minimize M(initial).  If multiple nodes could be removed to
# minimize M(initial), return such a node with the smallest index.
#
#
#
#
#
#
#
# Example 1:
#
#
# Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
# Output: 0
#
#
#
# Example 2:
#
#
# Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
# Output: 1
#
#
#
# Example 3:
#
#
# Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
# Output: 1
#
#
#
#
# Note:
#
#
# 1 < graph.length = graph[0].length <= 300
# 0 <= graph[i][j] == graph[j][i] <= 1
# graph[i][i] = 1
# 1 <= initial.length < graph.length
# 0 <= initial[i] < graph.length
#
#
#
#
#

# @lc code=start
from collections import defaultdict
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        conn = defaultdict(set)
        for i, row in enumerate(graph):
            for j, v in enumerate(row):
                if v == 1:
                    conn[i].add(j)
        infect = defaultdict(set)
        worst = 0
        for i in initial:
            to_visit = {i}
            visited = set(initial)
            while to_visit:
                visited.update(to_visit)
                new_visit = set()
                for j in to_visit:
                    new_visit.update(conn[j])
                to_visit = new_visit.difference(visited)
            infect[i] = visited

        infections = dict()
        for i, v in infect.items():
            for j in v:
                if j not in infections:
                    infections[j] = set()
                infections[j].add(i)

        #print(infections, infect)
        for i, v in infections.items():
            if len(v) >= 2:
                for j in v:
                    infect[j].discard(i)

        for i, v in infect.items():
            worst = max(worst, len(v))

        #print(infect, worst)

        for i in sorted(initial):
            if len(infect[i]) == worst:
                return i

        return initial[0]


# @lc code=end
